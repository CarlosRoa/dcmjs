{"version":3,"sources":["webpack://dcmjs/./adapters/Cornerstone/Segmentation.js"],"names":["Segmentation","imageIds","images","brushData","console","log","toolState","segments","image0","dims","x","columns","y","rows","z","length","xy","xyz","multiframe","includes","seg","createSegFromImages","numSegments","addMetaDataToSegAndGetSegCount","cToolsPixelData","Uint8ClampedArray","Warning","currentSeg","segIdx","imageIdSpecificToolState","brush","data","pixelData","p","dataSet","dataset","PixelData","ArrayBuffer","pixelDataUint8View","Uint8Array","bitArray","BitArray","pack","i","masks","dcmjs","j","lengthOfCubeInBytes","pixels","addSegment","isMultiframe","datasets","image","arrayBuffer","byteArray","buffer","dicomData","DicomMessage","readFile","DicomMetaDictionary","naturalizeDataset","dict","_meta","namifyDataset","meta","push","normalizers","Normalizer","normalizeToDataset","derivations","Columns","Rows","segmentSequence","SegmentSequence","unpack","segMetadata","seriesInstanceUid","SeriesInstanceUid","Array","isArray","segCount","imageId","invalidated"],"mappings":"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","file":"dcmjs.cfaa5c65d600ee687800.hot-update.js","sourcesContent":["export default class Segmentation {\n  constructor() {}\n\n  static generateToolState(imageIds, images, brushData) {\n    // NOTE: here be dragons. Currently if a brush has been used and then erased,\n    // This will flag up as a segmentation, even though its full of zeros.\n    // Fixing this cleanly really requires an update of cornerstoneTools.\n\n    console.log(\"testButton\");\n\n    const { toolState, segments } = brushData;\n\n    console.log(\"test2\");\n\n    console.log(images);\n\n    const image0 = images[0];\n\n    const dims = {\n      x: image0.columns,\n      y: image0.rows,\n      z: imageIds.length\n    };\n\n    dims.xy = dims.x * dims.y;\n    dims.xyz = dims.xy * dims.z;\n\n    const multiframe = imageIds[0].includes(\"?frame\");\n\n    const seg = Segmentation.createSegFromImages(images, multiframe);\n    const numSegments = Segmentation.addMetaDataToSegAndGetSegCount(\n      seg,\n      segments\n    );\n\n    const cToolsPixelData = new Uint8ClampedArray(dims.xyz * numSegments);\n\n    if (!numSegments) {\n      throw new Warning(\"No segments to export!\");\n    }\n\n    let currentSeg = 0;\n\n    for (let segIdx = 0; segIdx < segments.length; segIdx++) {\n      if (!segments[segIdx]) {\n        continue;\n      }\n\n      for (let z = 0; z < imageIds.length; z++) {\n        const imageIdSpecificToolState = toolState[imageIds[z]];\n\n        if (\n          imageIdSpecificToolState &&\n          imageIdSpecificToolState.brush &&\n          imageIdSpecificToolState.brush.data\n        ) {\n          const pixelData =\n            imageIdSpecificToolState.brush.data[segIdx].pixelData;\n\n          for (let p = 0; p < dims.xy; p++) {\n            cToolsPixelData[currentSeg * dims.xyz + z * dims.xy + p] =\n              pixelData[p];\n          }\n        }\n      }\n\n      currentSeg++;\n    }\n\n    console.log(cToolsPixelData);\n\n    const dataSet = seg.dataset;\n\n    // Re-define the PixelData ArrayBuffer to be the correct length\n    // => segments * rows * columns * slices / 8 (As 8 bits/byte)\n    seg.dataset.PixelData = new ArrayBuffer((numSegments * dims.xyz) / 8);\n\n    const pixelDataUint8View = new Uint8Array(seg.dataset.PixelData);\n\n    const bitArray = BitArray.pack(cToolsPixelData);\n\n    // Fill up the PixelData array with bitpacked segment information.\n    for (let i = 0; i < masks.length; i++) {\n      if (masks[i]) {\n        const bitArray = dcmjs.data.BitArray.pack(masks[i]);\n\n        for (let j = 0; j < lengthOfCubeInBytes; j++) {\n          pixels[i * lengthOfCubeInBytes + j] = bitArray[j];\n        }\n      }\n    }\n\n    // TODO -> save pixel data to seg.pixelData\n  }\n\n  static addMetaDataToSegAndGetSegCount(seg, segments) {\n    let numSegments = 0;\n\n    for (let i = 0; i < segments.length; i++) {\n      if (segments[i]) {\n        numSegments++;\n\n        seg.addSegment(segments[i]);\n      }\n    }\n\n    return numSegments;\n  }\n\n  /**\n   * @static createSegFromImages - description\n   *\n   * @param  {object} images       description\n   * @param  {Boolean} isMultiframe description\n   * @returns {dataSet}              description\n   */\n  static createSegFromImages(images, isMultiframe) {\n    const datasets = [];\n\n    if (isMultiframe) {\n      const image = images[0];\n      const arrayBuffer = image.data.byteArray.buffer;\n\n      const dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n      const dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n        dicomData.dict\n      );\n\n      dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(\n        dicomData.meta\n      );\n\n      datasets.push(dataset);\n    } else {\n      for (let i = 0; i < images.length; i++) {\n        const image = images[i];\n        const arrayBuffer = image.data.byteArray.buffer;\n        const dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n        const dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n          dicomData.dict\n        );\n\n        dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(\n          dicomData.meta\n        );\n        datasets.push(dataset);\n      }\n    }\n\n    const multiframe = dcmjs.normalizers.Normalizer.normalizeToDataset(\n      datasets\n    );\n\n    return new dcmjs.derivations.Segmentation([multiframe]);\n  }\n\n  static readToolState(imageIds, arrayBuffer) {\n    dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n    let dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n      dicomData.dict\n    );\n    dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(\n      dicomData.meta\n    );\n    const multiframe = dcmjs.normalizers.Normalizer.normalizeToDataset([\n      dataset\n    ]);\n\n    const dims = {\n      x: multiframe.Columns,\n      y: multiframe.Rows,\n      z: imageIds.length,\n      xy: multiframe.Columns * multiframe.Rows,\n      xyz: multiframe.Columns * multiframe.Rows * imageIds.length\n    };\n\n    const segmentSequence = multiframe.SegmentSequence;\n    const pixelData = dcmjs.data.BitArray.unpack(multiframe.PixelData);\n\n    //console.log(segmentSequence);\n\n    //console.log(multiframe);\n\n    const segMetadata = {\n      seriesInstanceUid: multiframe.SeriesInstanceUid,\n      data: []\n    };\n\n    const toolState = {};\n\n    if (Array.isArray(segmentSequence)) {\n      const segCount = segmentSequence.length;\n\n      for (let z = 0; z < imageIds.length; z++) {\n        const imageId = imageIds[z];\n\n        const imageIdSpecificToolState = {};\n\n        imageIdSpecificToolState.brush = {};\n        imageIdSpecificToolState.brush.data = [];\n\n        const brushData = imageIdSpecificToolState.brush.data;\n\n        for (let i = 0; i < segCount; i++) {\n          brushData[i] = {\n            invalidated: true,\n            pixelData: new Uint8ClampedArray(dims.x * dims.y)\n          };\n        }\n\n        toolState[imageId] = imageIdSpecificToolState;\n      }\n\n      for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n        segMetadata.data.push(segmentSequence[segIdx]);\n\n        for (let z = 0; z < imageIds.length; z++) {\n          const imageId = imageIds[z];\n\n          const cToolsPixelData =\n            toolState[imageId].brush.data[segIdx].pixelData;\n\n          for (let p = 0; p < dims.xy; p++) {\n            cToolsPixelData[p] = pixelData[segIdx * dims.xyz + z * dims.xy + p];\n          }\n        }\n      }\n    } else {\n      // Only one segment, will be stored as an object.\n      segMetadata.data.push(segmentSequence);\n\n      const segIdx = 0;\n\n      for (let z = 0; z < imageIds.length; z++) {\n        const imageId = imageIds[z];\n\n        const imageIdSpecificToolState = {};\n\n        imageIdSpecificToolState.brush = {};\n        imageIdSpecificToolState.brush.data = [];\n        imageIdSpecificToolState.brush.data[segIdx] = {\n          invalidated: true,\n          pixelData: new Uint8ClampedArray(dims.x * dims.y)\n        };\n\n        const cToolsPixelData =\n          imageIdSpecificToolState.brush.data[segIdx].pixelData;\n\n        for (let p = 0; p < dims.xy; p++) {\n          cToolsPixelData[p] = pixelData[z * dims.xy + p];\n        }\n\n        toolState[imageId] = imageIdSpecificToolState;\n      }\n    }\n\n    //console.log(toolState);\n\n    // TODO -> return seg metadata and brush tool data.\n\n    return { toolState, segMetadata };\n  }\n}\n"],"sourceRoot":""}
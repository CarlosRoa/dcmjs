{"version":3,"sources":["webpack://dcmjs/./adapters/Cornerstone/Segmentation.js"],"names":["Segmentation","imageIds","images","brushData","brushState","toolState","segments","datasets","multiframe","contains","seg","createSegFromImages","addMetaDataToSeg","masks","i","length","imageIdSpecificToolState","brsuh","brush","data","j","pixelData","mask","dataSet","dataset","numSegments","addSegment","isMultiframe","image","arrayBuffer","byteArray","buffer","dicomData","dcmjs","DicomMessage","readFile","DicomMetaDictionary","naturalizeDataset","dict","_meta","namifyDataset","meta","push","normalizers","Normalizer","normalizeToDataset","derivations","dims","x","Columns","y","Rows","z","xy","xyz","segmentSequence","SegmentSequence","BitArray","unpack","PixelData","segMetadata","seriesInstanceUid","SeriesInstanceUid","Array","isArray","segCount","imageId","invalidated","Uint8ClampedArray","segIndex","cToolsPixelData","p"],"mappings":"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","file":"dcmjs.0de425174569da03395d.hot-update.js","sourcesContent":["export default class Segmentation {\n  constructor() {}\n\n  static generateToolState(imageIds, images, brushData) {\n    // NOTE: here be dragons. Currently if a brush has been used and then erased,\n    // This will flag up as a segmentation, even though its full of zeros.\n    // Fixing this cleanly really requires an update of cornerstoneTools.\n\n    const { toolState, segments } = brushState;\n    const datasets = [];\n\n    const multiframe = imageIds[0].contains(\"?frame\");\n\n    const seg = Segmentation.createSegFromImages(images, multiframe);\n    Segmentation.addMetaDataToSeg(seg, segments);\n\n    const masks = [];\n\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageIdSpecificToolState = toolState[imageIds[i]];\n\n      if (\n        imageIdSpecificToolState.brsuh &&\n        imageIdSpecificToolState.brush.data\n      ) {\n        const brushData = imageIdSpecificToolState.brush.data;\n\n        for (j = 0; j < brushData; j++) {\n          if (brushData[j].pixelData) {\n            mask;\n          }\n        }\n      }\n    }\n\n    const dataSet = seg.dataset;\n\n    let numSegments = 0;\n\n    // TODO -> save pixel data to seg.pixelData\n  }\n\n  static addMetaDataToSeg(seg, segments) {\n    for (let i = 0; i < segments.length; i++) {\n      if (segments[i]) {\n        numSegments++;\n\n        seg.addSegment(segments[i]);\n      }\n    }\n  }\n\n  /**\n   * @static createSegFromImages - description\n   *\n   * @param  {object} images       description\n   * @param  {Boolean} isMultiframe description\n   * @returns {dataSet}              description\n   */\n  static createSegFromImages(images, isMultiframe) {\n    if (isMultiframe) {\n      const image = images[0];\n      const arrayBuffer = image.data.byteArray.buffer;\n\n      const dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n      const dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n        dicomData.dict\n      );\n\n      dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(\n        dicomData.meta\n      );\n\n      datasets.push(dataset);\n    } else {\n      for (let i = 0; i < images.length; i++) {\n        const image = images[i];\n        const arrayBuffer = image.data.byteArray.buffer;\n        const dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n        const dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n          dicomData.dict\n        );\n\n        dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(\n          dicomData.meta\n        );\n        datasets.push(dataset);\n      }\n    }\n\n    const multiframe = dcmjs.normalizers.Normalizer.normalizeToDataset(\n      datasets\n    );\n\n    return new dcmjs.derivations.Segmentation([multiframe]);\n  }\n\n  static readToolState(imageIds, arrayBuffer) {\n    dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n    let dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n      dicomData.dict\n    );\n    dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(\n      dicomData.meta\n    );\n    const multiframe = dcmjs.normalizers.Normalizer.normalizeToDataset([\n      dataset\n    ]);\n\n    const dims = {\n      x: multiframe.Columns,\n      y: multiframe.Rows,\n      z: imageIds.length,\n      xy: multiframe.Columns * multiframe.Rows,\n      xyz: multiframe.Columns * multiframe.Rows * imageIds.length\n    };\n\n    const segmentSequence = multiframe.SegmentSequence;\n    const pixelData = dcmjs.data.BitArray.unpack(multiframe.PixelData);\n\n    //console.log(segmentSequence);\n\n    //console.log(multiframe);\n\n    const segMetadata = {\n      seriesInstanceUid: multiframe.SeriesInstanceUid,\n      data: []\n    };\n\n    const toolState = {};\n\n    if (Array.isArray(segmentSequence)) {\n      const segCount = segmentSequence.length;\n\n      for (let z = 0; z < imageIds.length; z++) {\n        const imageId = imageIds[z];\n\n        const imageIdSpecificToolState = {};\n\n        imageIdSpecificToolState.brush = {};\n        imageIdSpecificToolState.brush.data = [];\n\n        const brushData = imageIdSpecificToolState.brush.data;\n\n        for (let i = 0; i < segCount; i++) {\n          brushData[i] = {\n            invalidated: true,\n            pixelData: new Uint8ClampedArray(dims.x * dims.y)\n          };\n        }\n\n        toolState[imageId] = imageIdSpecificToolState;\n      }\n\n      for (let segIndex = 0; segIndex < segmentSequence.length; segIndex++) {\n        segMetadata.data.push(segmentSequence[segIndex]);\n\n        for (let z = 0; z < imageIds.length; z++) {\n          const imageId = imageIds[z];\n\n          const cToolsPixelData =\n            toolState[imageId].brush.data[segIndex].pixelData;\n\n          for (let p = 0; p < dims.xy; p++) {\n            cToolsPixelData[p] =\n              pixelData[segIndex * dims.xyz + z * dims.xy + p];\n          }\n        }\n      }\n    } else {\n      // Only one segment, will be stored as an object.\n      segMetadata.data.push(segmentSequence);\n\n      const segIndex = 0;\n\n      for (let z = 0; z < imageIds.length; z++) {\n        const imageId = imageIds[z];\n\n        const imageIdSpecificToolState = {};\n\n        imageIdSpecificToolState.brush = {};\n        imageIdSpecificToolState.brush.data = [];\n        imageIdSpecificToolState.brush.data[segIndex] = {\n          invalidated: true,\n          pixelData: new Uint8ClampedArray(dims.x * dims.y)\n        };\n\n        const cToolsPixelData =\n          imageIdSpecificToolState.brush.data[segIndex].pixelData;\n\n        for (let p = 0; p < dims.xy; p++) {\n          cToolsPixelData[p] = pixelData[z * dims.xy + p];\n        }\n\n        toolState[imageId] = imageIdSpecificToolState;\n      }\n    }\n\n    //console.log(toolState);\n\n    // TODO -> return seg metadata and brush tool data.\n\n    return { toolState, segMetadata };\n  }\n}\n"],"sourceRoot":""}
{"version":3,"sources":["webpack://dcmjs/./adapters/Cornerstone/Segmentation.js"],"names":["Segmentation","stackOfImages","toolState","segMetadata","idx","segment","modules","brush","setters","metadata","_seriesInfo","seriesInstanceUid","imageIds","arrayBuffer","dicomData","dcmjs","data","DicomMessage","readFile","dataset","DicomMetaDictionary","naturalizeDataset","dict","_meta","namifyDataset","meta","multiframe","normalizers","Normalizer","normalizeToDataset","dims","x","Columns","y","Rows","z","length","xy","segmentSequence","SegmentSequence","pixelData","BitArray","unpack","PixelData","console","log","Array","isArray","i","push","imageIdSpecificToolState","invalidated","Uint8ClampedArray","p"],"mappings":";;;;;;;;;;;;;;;;;;;;IAAqBA,Y;AACnB,0BAAc;AAAA;AAAE;;;;sCAESC,a,EAAeC,S,EAAW,CAAE;;;oCAE9BC,W,EAAaC,G,EAAKC,O,EAAS;AAChDF,kBAAYC,GAAZ,IAAmBC,OAAnB;;AAEAC,cAAQC,KAAR,CAAcC,OAAd,CAAsBC,QAAtB,CACE,KAAKC,WAAL,CAAiBC,iBADnB,EAEEP,GAFF,EAGEC,OAHF;AAKD;;;kCAEoBO,Q,EAAUC,W,EAAa;AAC1CC,kBAAYC,MAAMC,IAAN,CAAWC,YAAX,CAAwBC,QAAxB,CAAiCL,WAAjC,CAAZ;AACA,UAAIM,UAAUJ,MAAMC,IAAN,CAAWI,mBAAX,CAA+BC,iBAA/B,CACZP,UAAUQ,IADE,CAAd;AAGAH,cAAQI,KAAR,GAAgBR,MAAMC,IAAN,CAAWI,mBAAX,CAA+BI,aAA/B,CACdV,UAAUW,IADI,CAAhB;AAGA,UAAMC,aAAaX,MAAMY,WAAN,CAAkBC,UAAlB,CAA6BC,kBAA7B,CAAgD,CACjEV,OADiE,CAAhD,CAAnB;;AAIA,UAAMW,OAAO;AACXC,WAAGL,WAAWM,OADH;AAEXC,WAAGP,WAAWQ,IAFH;AAGXC,WAAGvB,SAASwB,MAHD;AAIXC,YAAIX,WAAWM,OAAX,GAAqBN,WAAWQ;AAJzB,OAAb;;AAOA,UAAMI,kBAAkBZ,WAAWa,eAAnC;AACA,UAAMC,YAAYzB,MAAMC,IAAN,CAAWyB,QAAX,CAAoBC,MAApB,CAA2BhB,WAAWiB,SAAtC,CAAlB;;AAEAC,cAAQC,GAAR,CAAYnB,UAAZ;;AAEA,UAAMvB,cAAc,EAApB;;AAEA,UAAMD,YAAY,EAAlB;;AAEA,UAAI4C,MAAMC,OAAN,CAAcT,eAAd,CAAJ,EAAoC;AAClC,aAAK,IAAIU,IAAI,CAAb,EAAgBA,IAAIV,gBAAgBF,MAApC,EAA4CY,GAA5C,EAAiD;AAC/C7C,sBAAY8C,IAAZ,CAAiBX,gBAAgBU,CAAhB,CAAjB;;AAEA;;;;;AAKD;AACF,OAVD,MAUO;AACL;AACA7C,oBAAY8C,IAAZ,CAAiBX,eAAjB;;AAEA,aAAK,IAAIU,KAAI,CAAb,EAAgBA,KAAIpC,SAASwB,MAA7B,EAAqCY,IAArC,EAA0C;AACxC,cAAME,2BAA2B,EAAjC;;AAEAA,mCAAyB3C,KAAzB,GAAiC,EAAjC;AACA2C,mCAAyB3C,KAAzB,CAA+BS,IAA/B,GAAsC,EAAtC;AACAkC,mCAAyB3C,KAAzB,CAA+BS,IAA/B,CAAoC,CAApC,EAAuCmC,WAAvC,GAAqD,IAArD;AACAD,mCAAyB3C,KAAzB,CAA+BS,IAA/B,CAAoC,CAApC,EAAuCwB,SAAvC,GAAmD,IAAIY,iBAAJ,CACjDtB,KAAKC,CAAL,GAASD,KAAKG,CADmC,CAAnD;;AAIA,cAAMO,aAAYU,yBAAyB3C,KAAzB,CAA+BS,IAA/B,CAAoC,CAApC,EAAuCwB,SAAzD;;AAEA,eAAK,IAAIa,IAAI,CAAb,EAAgBA,IAAIvB,KAAKO,EAAzB,EAA6BgB,GAA7B,EAAkC;AAChCb,uBAAUa,CAAV,IAAe,CAACL,KAAIlB,KAAKO,EAAT,GAAcgB,CAAf,CAAf;AACD;;AAEDnD,oBAAUU,SAASoC,EAAT,CAAV,IAAyBE,wBAAzB;AACD;;AAEDN,gBAAQC,GAAR,CAAY3C,SAAZ;;AAEA;;;;;AAKD;;AAED;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AA6BD;;;;;;kBApHkBF,Y","file":"dcmjs.71c83837e6d73053efc4.hot-update.js","sourcesContent":["export default class Segmentation {\n  constructor() {}\n\n  static generateToolState(stackOfImages, toolState) {}\n\n  static _setSegMetadata(segMetadata, idx, segment) {\n    segMetadata[idx] = segment;\n\n    modules.brush.setters.metadata(\n      this._seriesInfo.seriesInstanceUid,\n      idx,\n      segment\n    );\n  }\n\n  static readToolState(imageIds, arrayBuffer) {\n    dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);\n    let dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(\n      dicomData.dict\n    );\n    dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(\n      dicomData.meta\n    );\n    const multiframe = dcmjs.normalizers.Normalizer.normalizeToDataset([\n      dataset\n    ]);\n\n    const dims = {\n      x: multiframe.Columns,\n      y: multiframe.Rows,\n      z: imageIds.length,\n      xy: multiframe.Columns * multiframe.Rows\n    };\n\n    const segmentSequence = multiframe.SegmentSequence;\n    const pixelData = dcmjs.data.BitArray.unpack(multiframe.PixelData);\n\n    console.log(multiframe);\n\n    const segMetadata = [];\n\n    const toolState = {};\n\n    if (Array.isArray(segmentSequence)) {\n      for (let i = 0; i < segmentSequence.length; i++) {\n        segMetadata.push(segmentSequence[i]);\n\n        /*\n        for (let j = 0; j < dimensions.cube; j++) {\n          mask[j] = pixelData[i * dimensions.cube + j];\n        }\n        */\n      }\n    } else {\n      // Only one segment, will be stored as an object.\n      segMetadata.push(segmentSequence);\n\n      for (let i = 0; i < imageIds.length; i++) {\n        const imageIdSpecificToolState = {};\n\n        imageIdSpecificToolState.brush = {};\n        imageIdSpecificToolState.brush.data = [];\n        imageIdSpecificToolState.brush.data[0].invalidated = true;\n        imageIdSpecificToolState.brush.data[0].pixelData = new Uint8ClampedArray(\n          dims.x * dims.y\n        );\n\n        const pixelData = imageIdSpecificToolState.brush.data[0].pixelData;\n\n        for (let p = 0; p < dims.xy; p++) {\n          pixelData[p] = [i * dims.xy + p];\n        }\n\n        toolState[imageIds[i]] = imageIdSpecificToolState;\n      }\n\n      console.log(toolState);\n\n      /*\n      for (let j = 0; j < dimensions.cube; j++) {\n        mask[j] = pixelData[j];\n      }\n      */\n    }\n\n    // TODO -> return seg metadata and brush tool data.\n\n    /*\n    const { globalImageIdSpecificToolStateManager } = cornerstoneTools;\n\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n      const byteOffset = width * height * i;\n      const length = width * height;\n      const slicePixelData = new Uint8ClampedArray(buffer, byteOffset, length);\n\n      const toolData = [];\n      toolData[segmentationIndex] = {\n        pixelData: slicePixelData,\n        invalidated: true\n      };\n\n      const toolState =\n        globalImageIdSpecificToolStateManager.saveImageIdToolState(imageId) ||\n        {};\n\n      toolState[toolType] = {\n        data: toolData\n      };\n\n      globalImageIdSpecificToolStateManager.restoreImageIdToolState(\n        imageId,\n        toolState\n      );\n    }\n    */\n  }\n}\n"],"sourceRoot":""}
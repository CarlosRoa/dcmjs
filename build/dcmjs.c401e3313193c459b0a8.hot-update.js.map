{"version":3,"sources":["webpack://dcmjs/./bitArray.js"],"names":["BitArray","getBytesForBinaryFrame","pack","unpack","numPixels","remainder","bytesRequired","Math","floor","pixelData","length","console","log","bitPixelData","Uint8Array","bytePos","i","pixValue","bitPixelValue","bitPixelArray","bitArray","byteArray","byteIndex","bitIndex","bitByteIndex"],"mappings":";;;;;;;;;;;;;;;AAAA;;AAEA,IAAMA,WAAW;AACfC,gDADe;AAEfC,YAFe;AAGfC;AAHe,CAAjB;;QAMSH,Q,GAAAA,Q;;;AAET,SAASC,sBAAT,CAAiCG,SAAjC,EAA4C;AAC1C;AACA,MAAMC,YAAYD,YAAY,CAA9B;;AAEA;AACA,MAAIE,gBAAgBC,KAAKC,KAAL,CAAWJ,YAAY,CAAvB,CAApB;;AAEA;AACA,MAAIC,YAAY,CAAhB,EAAmB;AACjBC;AACD;;AAED,SAAOA,aAAP;AACD;;AAED,SAASJ,IAAT,CAAeO,SAAf,EAA0B;AACxB,MAAML,YAAYK,UAAUC,MAA5B;AACAC,UAAQC,GAAR,CAAY,gBAAgBR,SAA5B;;AAEA,MAAMM,SAAST,uBAAuBG,SAAvB,CAAf;AACA;;AAEA,MAAMS,eAAe,IAAIC,UAAJ,CAAeJ,MAAf,CAArB;;AAEA,MAAIK,UAAU,CAAd;;AAEA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIZ,SAApB,EAA+BY,GAA/B,EAAoC;AAClC;AACAD,cAAUR,KAAKC,KAAL,CAAWQ,IAAI,CAAf,CAAV;;AAEA,QAAMC,WAAYR,UAAUO,CAAV,MAAiB,CAAnC;;AAEA;AACA;AACA;;AAEA,QAAME,gBAAgBD,YAAaD,IAAI,CAAvC;AACA;AACA;;AAEAH,iBAAaE,OAAb,KAAyBG,aAAzB;;AAEA;AACD;;AAED,SAAOL,YAAP;AACD;;AAED;AACA;AACA,SAASV,MAAT,CAAgBgB,aAAhB,EAA+B;AAC7B,MAAMC,WAAW,IAAIN,UAAJ,CAAeK,aAAf,CAAjB;AACA,MAAME,YAAY,IAAIP,UAAJ,CAAe,IAAEM,SAASV,MAA1B,CAAlB;;AAEA,OAAK,IAAIY,YAAY,CAArB,EAAwBA,YAAYD,UAAUX,MAA9C,EAAsDY,WAAtD,EAAmE;AACjE,QAAMC,WAAWD,YAAU,CAA3B;AACA,QAAME,eAAejB,KAAKC,KAAL,CAAWc,YAAU,CAArB,CAArB;AACAD,cAAUC,SAAV,IAAuB,OAAQ,CAACF,SAASI,YAAT,IAA0B,KAAGD,QAA9B,KAA4CA,QAApD,CAAvB;AACD;;AAED,SAAOF,SAAP;AACD,C","file":"dcmjs.c401e3313193c459b0a8.hot-update.js","sourcesContent":["/* eslint no-bitwise: 0 */\n\nconst BitArray = {\n  getBytesForBinaryFrame,\n  pack,\n  unpack\n};\n\nexport { BitArray }\n\nfunction getBytesForBinaryFrame (numPixels) {\n  // Check whether the 1-bit pixels exactly fit into bytes\n  const remainder = numPixels % 8;\n\n  // Number of bytes that work on an exact fit\n  let bytesRequired = Math.floor(numPixels / 8);\n\n  // Add one byte if we have a remainder\n  if (remainder > 0) {\n    bytesRequired++;\n  }\n\n  return bytesRequired;\n}\n\nfunction pack (pixelData) {\n  const numPixels = pixelData.length;\n  console.log('numPixels: ' + numPixels);\n\n  const length = getBytesForBinaryFrame(numPixels);\n  //console.log('getBytesForBinaryFrame: ' + length);\n\n  const bitPixelData = new Uint8Array(length);\n\n  let bytePos = 0;\n\n  for (let i = 0; i < numPixels; i++) {\n    // Compute byte position\n    bytePos = Math.floor(i / 8);\n\n    const pixValue = (pixelData[i] !== 0);\n\n    //console.log('i: ' + i);\n    //console.log('pixValue: ' + pixValue);\n    //console.log('bytePos: ' + bytePos);\n\n    const bitPixelValue = pixValue << (i % 8);\n    //console.log('current bitPixelData: ' + bitPixelData[bytePos]);\n    //console.log('this bitPixelValue: ' + bitPixelValue);\n\n    bitPixelData[bytePos] |= bitPixelValue;\n\n    //console.log('new bitPixelValue: ' + bitPixelData[bytePos]);\n  }\n\n  return bitPixelData;\n}\n\n// convert a packed bitwise pixel array into a byte-per-pixel\n// array with 255 corresponding to each set bit in the bit array\nfunction unpack(bitPixelArray) {\n  const bitArray = new Uint8Array(bitPixelArray);\n  const byteArray = new Uint8Array(8*bitArray.length);\n\n  for (let byteIndex = 0; byteIndex < byteArray.length; byteIndex++) {\n    const bitIndex = byteIndex%8;\n    const bitByteIndex = Math.floor(byteIndex/8);\n    byteArray[byteIndex] = 255 * ( (bitArray[bitByteIndex] & (1<<bitIndex)) >> bitIndex );\n  }\n\n  return byteArray;\n}\n"],"sourceRoot":""}
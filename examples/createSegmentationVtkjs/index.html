<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="user-scalable=no, width=device-width, initial-scale=1, maximum-scale=1"
    />

    <link href="../css/bootstrap.min.css" rel="stylesheet" />
    <link href="../css/cornerstone.min.css" rel="stylesheet" />
  </head>
  <body>
    <div class="container">
      <div class="page-header">
        <h1>vtkjs: Create DICOM Segmentation IOD</h1>
        <p>
          This example demonstrates how to create a DICOM Segmentation object
          with vtkjs.
        </p>
        <a href="../index.html">Go back to the Examples page</a>
      </div>

      <div class="row">
        <button id="sampleData" onclick="createSeg()">Create Seg</button>
        <p id="statusLine"></p>
        <div class="col-xs-9">
          <div
            style="width:512px;height:512px;position:relative;display:inline-block;"
            oncontextmenu="return false"
            class="cornerstone-enabled-image"
            unselectable="on"
            onselectstart="return false;"
            onmousedown="return false;"
          >
            <div
              id="vtkjsViewport"
              style="width:512px;height:512px;top:0px;left:0px; position:absolute;"
            ></div>
          </div>
          <p>
            Sample data is from the dicom4qi connectathon event to be held at
            RSNA 2017. This is
            <a
              href="https://qiicr.gitbooks.io/dicom4qi/content/instructions/seg.html#test-dataset-2"
              >test dataset #2</a
            >
          </p>
        </div>
      </div>
    </div>

    <script src="../js/jquery.min.js"></script>
    <script src="../js/jqueryFileDrop.js"></script>
    <script src="../js/jszip.min.js"></script>

    <script src="https://unpkg.com/cornerstone-core@2.2.6/dist/cornerstone.js"></script>
    <script src="https://unpkg.com/cornerstone-math@0.1.6/dist/cornerstoneMath.js"></script>
    <script src="https://unpkg.com/cornerstone-tools@3.0.0-b.1585/dist/cornerstoneTools.js"></script>

    <script src="https://unpkg.com/dicom-parser/dist/dicomParser.js"></script>
    <script src="https://unpkg.com/cornerstone-wado-image-loader/dist/cornerstoneWADOImageLoader.min.js"></script>
    <script src="https://unpkg.com/hammerjs/hammer.min.js"></script>

    <script src="../js/initCornerstone.js"></script>

    <script src="../../build/dcmjs.js"></script>

    <script
      src="https://unpkg.com/react@16/umd/react.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>

    <script>
      "use strict";

      var process = {
        env: {
          NODE_ENV: "production"
        }
      };

      window.process = process;
    </script>

    <script src="https://unpkg.com/react-vtkjs-viewport@0.0.2/dist/index.js"></script>
    <script src="https://unpkg.com/vtk.js/dist/vtk.js"></script>

    <script>
      function setupSyncedBrush(imageDataObject, element) {
        // Create buffer the size of the 3D volume
        const dimensions = imageDataObject.dimensions;
        const width = dimensions[0];
        const height = dimensions[1];
        const depth = dimensions[2];
        const numVolumePixels = width * height * depth;
        const threeDimensionalPixelData = new Uint8ClampedArray(
          numVolumePixels
        );
        const buffer = threeDimensionalPixelData.buffer;

        // Slice buffer into 2d-sized pieces, which are added to Cornerstone ToolData
        const toolType = "brush";
        const segmentationIndex = 0;
        const imageIds = imageDataObject.imageIds;
        if (imageIds.length !== depth) {
          throw new Error("Depth should match the number of imageIds");
        }

        const { globalImageIdSpecificToolStateManager } = cornerstoneTools;

        for (let i = 0; i < imageIds.length; i++) {
          const imageId = imageIds[i];
          const byteOffset = width * height * i;
          const length = width * height;
          const slicePixelData = new Uint8ClampedArray(
            buffer,
            byteOffset,
            length
          );

          const toolData = [];
          toolData[segmentationIndex] = {
            pixelData: slicePixelData,
            invalidated: true
          };

          const toolState =
            globalImageIdSpecificToolStateManager.saveImageIdToolState(
              imageId
            ) || {};

          toolState[toolType] = {
            data: toolData
          };

          globalImageIdSpecificToolStateManager.restoreImageIdToolState(
            imageId,
            toolState
          );
        }

        // Create VTK Image Data with buffer as input
        const labelMap = vtk.Common.DataModel.vtkImageData.newInstance();

        labelMap.setDimensions(...dimensions);

        // right now only support 256 labels
        const dataArray = vtk.Common.Core.vtkDataArray.newInstance({
          numberOfComponents: 1, // labelmap with single component
          values: threeDimensionalPixelData
        });
        labelMap.getPointData().setScalars(dataArray);
        labelMap.setSpacing(...imageDataObject.vtkImageData.getSpacing());
        labelMap.setOrigin(...imageDataObject.vtkImageData.getOrigin());
        labelMap.setDirection(...imageDataObject.vtkImageData.getDirection());

        return labelMap;
      }

      let metaData = {};

      function createSeg() {
        console.log("TODO!");

        const labelMap = labelMapInputData
          .getPointData()
          .getScalars()
          .getData();

        const segments: [
          {
            SegmentedPropertyCategoryCodeSequence: {
              CodeValue: "T-D0050",
              CodingSchemeDesignator: "SRT",
              CodeMeaning: "Tissue"
            },
            SegmentNumber: 1,
            SegmentLabel: "Tissue",
            SegmentAlgorithmType: "SEMIAUTOMATIC",
            SegmentAlgorithmName: "Slicer Prototype",
            RecommendedDisplayCIELabValue,
            SegmentedPropertyTypeCodeSequence: {
              CodeValue: "T-D0050",
              CodingSchemeDesignator: "SRT",
              CodeMeaning: "Tissue"
            }
          }
        ];

        dcmjs.adapters.VTKjs.Segmentation.createSEG(labelMap, images, segments);



      }

      function addMetaData(type, imageId, data) {
        metaData[imageId] = metaData[imageId] || {};
        metaData[imageId][type] = data;
      }

      //
      // creates an array of per-frame imageIds in the form needed for cornerstone processing.
      //
      function getImageIds(multiframe, baseImageId) {
        const imageIds = [];
        const numFrames = Number(multiframe.NumberOfFrames);
        for (let i = 0; i < numFrames; i++) {
          let segNum;
          if (
            multiframe.PerFrameFunctionalGroupsSequence[i]
              .SegmentIdentificationSequence
          ) {
            segNum =
              multiframe.PerFrameFunctionalGroupsSequence[i]
                .SegmentIdentificationSequence.ReferencedSegmentNumber;
          }
          const imageId = baseImageId + "?frame=" + i;
          imageIds.push(imageId);
        }
        return imageIds;
      }

      //
      // uses cornerstone caching to access a bytearray of the
      // part10 dicom, then uses dcmjs to parse this
      // into javascript object and populates the
      // metadata for the per-frame imageIDs.
      //
      function loadMultiFrameAndPopulateMetadata(baseImageId) {
        return new Promise(function(resolve, reject) {
          var multiframe;
          cornerstone.loadAndCacheImage(baseImageId).then(function(image) {
            var arrayBuffer = image.data.byteArray.buffer;

            dicomData = dcmjs.data.DicomMessage.readFile(arrayBuffer);
            let dataset = dcmjs.data.DicomMetaDictionary.naturalizeDataset(
              dicomData.dict
            );
            dataset._meta = dcmjs.data.DicomMetaDictionary.namifyDataset(
              dicomData.meta
            );

            multiframe = dcmjs.normalizers.Normalizer.normalizeToDataset([
              dataset
            ]);

            const numFrames = Number(multiframe.NumberOfFrames);
            for (let i = 0; i < numFrames; i++) {
              const imageId = baseImageId + "?frame=" + i;

              var functionalGroup =
                multiframe.PerFrameFunctionalGroupsSequence[i];
              var imagePositionArray =
                functionalGroup.PlanePositionSequence.ImagePositionPatient;

              addMetaData("imagePlane", imageId, {
                imagePositionPatient: {
                  x: imagePositionArray[0],
                  y: imagePositionArray[1],
                  z: imagePositionArray[2]
                }
              });
            }

            resolve(multiframe);
          });
        });
      }
    </script>

    <script>
      "use strict";

      var { VTKMPRViewport, getImageData, loadImageData } = window.VTKViewport;

      var labelMapInputData;

      var imageIds = [
        "dicomweb://s3.amazonaws.com/lury/PTCTStudy/1.3.6.1.4.1.25403.52237031786.3872.20100510032220.11.dcm",
        "dicomweb://s3.amazonaws.com/lury/PTCTStudy/1.3.6.1.4.1.25403.52237031786.3872.20100510032220.12.dcm"
      ];

      const imagePromises = imageIds.map(imageId => {
        return cornerstone.loadAndCacheImage(imageId);
      });

      var images;

      Promise.all(imagePromises).then(
        result => {
          images = result;

          const displaySetInstanceUid = "12345";
          const cornerstoneViewportData = {
            stack: {
              imageIds,
              currentImageIdIndex: 0
            },
            displaySetInstanceUid
          };

          const imageDataObject = getImageData(
            imageIds,
            displaySetInstanceUid,
            cornerstone
          );

          const doneLoadingCallback = () => {
            labelMapInputData = setupSyncedBrush(imageDataObject);
            console.log(
              labelMapInputData
                .getPointData()
                .getScalars()
                .getData()
            );
            var props = {
              data: imageDataObject.vtkImageData,
              labelmap: labelMapInputData,
              painting: true
            };

            var app = React.createElement(VTKMPRViewport, props, null);

            ReactDOM.render(app, document.getElementById("vtkjsViewport"));
          };
          const callbacks = [doneLoadingCallback];

          loadImageData(imageDataObject, callbacks, cornerstone);
        },
        error => {
          throw new Error(error);
        }
      );
    </script>
  </body>
</html>
